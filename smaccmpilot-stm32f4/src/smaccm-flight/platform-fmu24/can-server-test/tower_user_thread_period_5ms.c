/* This file has been autogenerated by Ivory
 * Compiler version  0.1.0.5
 */
#include "tower_user_thread_period_5ms.h"

static void emitter_set_chan_190(const struct i2c_transaction_request *n_var0);

static void emitter_i2c2_request_chan_191(const struct i2c_transaction_result *n_var0);

static void emitter_new_state_chan_29(const struct sensors_result *n_var0);

static void emitter_att_est_gyro_chan_189(const struct AhrsMlkf *n_var0);

static void emitter_att_est_accel_chan_189(const struct AhrsMlkf *n_var0);

static void emitter_write_gyro_output_attr_chan_30(const struct gyroscope_sample *n_var0);

static void emitter_write_accel_output_attr_chan_31(const struct accelerometer_sample *n_var0);

static void emitter_motion_light_debug_2_chan_23(const struct rgb_led_setting *n_var0);

static void emitter_detectMotion_2_accel_chan_188(const bool *n_var0);

static void emitter_spi1_scheduler_mpu6000_chan_158(const struct spi_transaction_request *n_var0);

static void emitter_period_chan_167(const struct spi_transaction_request *n_var0);

static void emitter_period_chan_157(const struct gyroscope_sample *n_var0);

static void emitter_period_chan_156(const struct accelerometer_sample *n_var0);

void callback_i2c_response_thread_period_5ms(const struct i2c_transaction_result *n_var0)
{
    bool n_deref0 = expect_response;
    
    if (n_deref0) {
        uint8_t n_deref1 = n_var0->resultcode;
        
        if ((bool) (n_deref1 > 0)) {
            error = (uint8_t) 3U;
        }
    } else {
        error = (uint8_t) 2U;
    }
    expect_response = false;
}

void callback_set_thread_period_5ms(const struct rgb_led_setting *n_var0)
{
    bool n_deref0 = expect_response;
    
    if ((bool) !n_deref0) {
        expect_response = true;
        
        uint8_t n_deref1 = n_var0->red;
        uint8_t n_deref2 = n_var0->green;
        uint8_t n_deref3 = n_var0->blue;
        struct i2c_transaction_request n_local4 = {.tx_addr =(uint8_t) 85U, .tx_buf ={(uint8_t) 129U, (uint8_t) ((bool) (n_deref3 > (uint8_t) 15U) ? (uint8_t) 15U : n_deref3), (uint8_t) 130U, (uint8_t) ((bool) (n_deref2 > (uint8_t) 15U) ? (uint8_t) 15U : n_deref2), (uint8_t) 131U, (uint8_t) ((bool) (n_deref1 > (uint8_t) 15U) ? (uint8_t) 15U : n_deref1)}, .tx_len =(int32_t) 6, .rx_len =
                                                   (int32_t) 0};
        struct i2c_transaction_request *n_ref5 = &n_local4;
        
        emitter_set_chan_190(n_ref5);
    }
}

void callback_i2c2_request_thread_period_5ms(const struct i2c_transaction_request *n_var0)
{
    bool n_deref0 = i2c2_ready_sent;
    uint8_t n_deref1 = i2c2_driverstate;
    
    if ((bool) (n_deref0 && (bool) (0 == n_deref1))) {
        /* reg get i2c2->cr1:  */
        ;
        
        uint16_t n_r2 = ivory_hw_io_read_u16((uint32_t) 1073764352U);
        
        if ((bool) ((bool) (0 != (uint8_t) (uint16_t) ((uint16_t) (n_r2 >> (uint16_t) 8U) & (uint16_t) 1U)) || (bool) (0 != (uint8_t) (uint16_t) ((uint16_t) (n_r2 >> (uint16_t) 9U) & (uint16_t) 1U)))) {
            uint32_t n_deref3 = i2c2_error_run;
            
            i2c2_error_run = (uint32_t) ((uint32_t) 1U + n_deref3);
            
            uint16_t n_r4 = ivory_hw_io_read_u16((uint32_t) 1073764372U);
            
            /* reg modify i2c2->sr1: clearBit i2c_sr1_smbalert, clearBit i2c_sr1_timeout, clearBit i2c_sr1_pecerr, clearBit i2c_sr1_ovr, clearBit i2c_sr1_af, clearBit i2c_sr1_arlo, clearBit i2c_sr1_berr, clearBit i2c_sr1_txe, clearBit i2c_sr1_rxne, clearBit i2c_sr1_stopf, clearBit i2c_sr1_add10, clearBit i2c_sr1_btf, clearBit i2c_sr1_addr, clearBit i2c_sr1_sb */
            ;
            
            uint16_t n_cse31 = (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 10U);
            uint16_t n_cse34 = (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 9U);
            uint16_t n_cse37 = (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 8U);
            
            ivory_hw_io_write_u16((uint32_t) 1073764372U, (uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) (n_r4 & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 15U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 14U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U <<
                                                                                                                                                                                                                                                                                                                                                                                         (uint16_t) 12U)) &
                                                                                                                                                                                              (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 11U)) & n_cse31) & n_cse34) & n_cse37) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 7U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 6U)) &
                                                                                                                      (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 4U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 3U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 2U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 1U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << 0)));
            
            uint16_t n_r5 = ivory_hw_io_read_u16((uint32_t) 1073764356U);
            
            /* reg modify i2c2->cr2: clearBit i2c_cr2_itbufen, clearBit i2c_cr2_itevten, clearBit i2c_cr2_iterren */
            ;
            ivory_hw_io_write_u16((uint32_t) 1073764356U, (uint16_t) ((uint16_t) ((uint16_t) (n_cse37 & n_cse34) & n_cse31) & n_r5));
            
            uint8_t n_deref6 = i2c2_driverstate;
            
            i2c2_driverstate = (uint8_t) 0U;
            i2c2_resbuffer.resultcode = (uint8_t) 1U;
            
            uint32_t n_deref7 = i2c2_error_run;
            
            i2c2_error_run = (uint32_t) ((uint32_t) 1U + n_deref7);
            emitter_i2c2_request_chan_191(&i2c2_resbuffer);
        } else {
            /* reg set i2c2->cr1: setBit i2c_cr1_pe */
            ;
            ivory_hw_io_write_u16((uint32_t) 1073764352U, (uint16_t) ((uint16_t) 1U << 0));
            i2c2_driverstate = (uint8_t) 1U;
            i2c2_reqbuffer = *n_var0;
            i2c2_reqbufferpos = (int32_t) 0;
            i2c2_resbufferpos = (int32_t) 0;
            
            int64_t n_r8 = tower_get_time();
            
            i2c2_last_event = n_r8;
            
            uint16_t n_r9 = ivory_hw_io_read_u16((uint32_t) 1073764356U);
            
            /* reg modify i2c2->cr2: setBit i2c_cr2_itbufen, setBit i2c_cr2_itevten, setBit i2c_cr2_iterren */
            ;
            
            uint16_t n_cse73 = (uint16_t) ((uint16_t) 1U << (uint16_t) 8U);
            
            ivory_hw_io_write_u16((uint32_t) 1073764356U, (uint16_t) ((uint16_t) ((uint16_t) (n_cse73 | (uint16_t) ((uint16_t) 1U << (uint16_t) 9U)) | (uint16_t) ((uint16_t) 1U << (uint16_t) 10U)) | n_r9));
            
            uint16_t n_r10 = ivory_hw_io_read_u16((uint32_t) 1073764352U);
            
            /* reg modify i2c2->cr1: setBit i2c_cr1_start */
            ;
            ivory_hw_io_write_u16((uint32_t) 1073764352U, (uint16_t) (n_cse73 | n_r10));
            for (int32_t n_ix11 = (int32_t) 14; n_ix11 >= (int32_t) 0; n_ix11--) {
                /* reg get i2c2->cr1:  */
                ;
                
                uint16_t n_r12 = ivory_hw_io_read_u16((uint32_t) 1073764352U);
                
                if ((bool) (0 == (uint8_t) (uint16_t) ((uint16_t) (n_r12 >> (uint16_t) 8U) & (uint16_t) 1U))) {
                    break;
                }
            }
        }
    } else {
        uint32_t n_deref13 = i2c2_invalid_request;
        
        i2c2_invalid_request = (uint32_t) ((uint32_t) 1U + n_deref13);
        
        uint16_t n_r14 = ivory_hw_io_read_u16((uint32_t) 1073764372U);
        
        /* reg modify i2c2->sr1: clearBit i2c_sr1_smbalert, clearBit i2c_sr1_timeout, clearBit i2c_sr1_pecerr, clearBit i2c_sr1_ovr, clearBit i2c_sr1_af, clearBit i2c_sr1_arlo, clearBit i2c_sr1_berr, clearBit i2c_sr1_txe, clearBit i2c_sr1_rxne, clearBit i2c_sr1_stopf, clearBit i2c_sr1_add10, clearBit i2c_sr1_btf, clearBit i2c_sr1_addr, clearBit i2c_sr1_sb */
        ;
        
        uint16_t n_cse112 = (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 8U);
        uint16_t n_cse114 = (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 9U);
        uint16_t n_cse116 = (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 10U);
        
        ivory_hw_io_write_u16((uint32_t) 1073764372U, (uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ((uint16_t) ~(uint16_t) ((uint16_t) 1U << 0) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 1U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 2U)) &
                                                                                                                                                                                                      (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 3U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 4U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 6U)) &
                                                                                                                                                                  (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 7U)) & n_cse112) & n_cse114) & n_cse116) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 11U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 12U)) &
                                                                                          (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 14U)) & (uint16_t) ~(uint16_t) ((uint16_t) 1U << (uint16_t) 15U)) & n_r14));
        
        uint16_t n_r15 = ivory_hw_io_read_u16((uint32_t) 1073764356U);
        
        /* reg modify i2c2->cr2: clearBit i2c_cr2_itbufen, clearBit i2c_cr2_itevten, clearBit i2c_cr2_iterren */
        ;
        ivory_hw_io_write_u16((uint32_t) 1073764356U, (uint16_t) ((uint16_t) ((uint16_t) (n_cse112 & n_cse114) & n_cse116) & n_r15));
        
        uint8_t n_deref16 = i2c2_driverstate;
        
        i2c2_driverstate = (uint8_t) 0U;
        i2c2_resbuffer.resultcode = (uint8_t) 1U;
        
        uint32_t n_deref17 = i2c2_error_run;
        
        i2c2_error_run = (uint32_t) ((uint32_t) 1U + n_deref17);
        emitter_i2c2_request_chan_191(&i2c2_resbuffer);
    }
}

void callback_new_state_thread_period_5ms(const struct AhrsMlkf *n_var0)
{
    const float *n_cse0 = n_var0->ltp_to_imu_quat;
    float n_deref0 = n_cse0[(int32_t) 0];
    float n_deref1 = n_cse0[(int32_t) 1];
    float n_deref2 = n_cse0[(int32_t) 2];
    float n_deref3 = n_cse0[(int32_t) 3];
    const float *n_cse9 = n_var0->lp_rates;
    float n_deref4 = n_cse9[(int32_t) 0];
    float n_deref5 = n_cse9[(int32_t) 1];
    float n_deref6 = n_cse9[(int32_t) 2];
    const struct xyz *n_cse16 = &last_accel.sample;
    float n_deref7 = n_cse16->x;
    float n_deref8 = n_cse16->y;
    float n_deref9 = n_cse16->z;
    bool n_deref10 = last_accel.samplefail;
    bool n_deref11 = last_mag.samplefail;
    int64_t n_deref12 = last_baro.time;
    float n_deref13 = last_baro.pressure;
    bool n_deref14 = last_baro.samplefail;
    int64_t n_deref15 = last_gyro.time;
    bool n_deref16 = last_gyro.samplefail;
    float n_deref17 = last_lidar.distance;
    int64_t n_deref18 = last_lidar.time;
    bool n_deref19 = last_lidar.samplefail;
    bool n_let20 = (bool) ((bool) !n_deref10 && (bool) ((bool) !n_deref11 && (bool) ((bool) !n_deref14 && (bool) ((bool) !n_deref16 && (bool) !n_deref19))));
    bool n_let21 = (bool) ((bool) (n_deref0 != 0.0f) || (bool) ((bool) (0.0f != n_deref1) || (bool) ((bool) (0.0f != n_deref2) || (bool) (0.0f != n_deref3))));
    float n_cse52 = (float) (n_deref2 * n_deref2);
    struct sensors_result n_local22 = {.valid =(bool) (n_let20 && n_let21), .roll =(float) atan2f((float) (2.0f * (float) ((float) (n_deref0 * n_deref1) + (float) (n_deref2 * n_deref3))), (float) (1.0f - (float) (2.0f * (float) ((float) (n_deref1 * n_deref1) + n_cse52)))), .pitch =(float) asinf((float) (2.0f * (float) ((float) (n_deref0 * n_deref2) - (float) (n_deref1 * n_deref3)))), .yaw =
                                       (float) atan2f((float) (2.0f * (float) ((float) (n_deref0 * n_deref3) + (float) (n_deref1 * n_deref2))), (float) (1.0f - (float) (2.0f * (float) (n_cse52 + (float) (n_deref3 * n_deref3))))), .omega ={.x =n_deref4, .y =n_deref5, .z =n_deref6}, .attitude ={.quat_a =n_deref0, .quat_b =n_deref1, .quat_c =n_deref2, .quat_d =n_deref3}, .baro_alt =
                                       (float) ((float) ((float) (288.15f / (float) powf((float) ((float) (n_deref13 * 100.0f) / 101325.0f), (float) (-5.4043077e-2f / 0.28404373f))) - 288.15f) / -6.5e-3f), .lidar_alt =n_deref17, .accel ={.x =n_deref7, .y =n_deref8, .z =n_deref9}, .ahrs_time =n_deref15, .baro_time =n_deref12, .lidar_time =n_deref18};
    struct sensors_result *n_ref23 = &n_local22;
    
    emitter_new_state_chan_29(n_ref23);
}

void callback_save_last_gyro_thread_period_5ms(const struct gyroscope_sample *n_var0)
{
    last_gyro = *n_var0;
}

void callback_save_last_accel_thread_period_5ms(const struct accelerometer_sample *n_var0)
{
    last_accel = *n_var0;
}

void callback_att_est_motion_thread_period_5ms(const bool *n_var0)
{
    in_motion = *n_var0;
}

void callback_att_est_gyro_thread_period_5ms(const struct gyroscope_sample *n_var0)
{
    bool n_deref0 = n_var0->samplefail;
    
    if ((bool) !n_deref0) {
        att_est_last_gyro_rads = *n_var0;
        
        bool n_deref1 = att_est_aligned;
        
        if (n_deref1) {
            int64_t n_deref2 = att_est_last_gyro_time;
            int64_t n_r3 = tower_get_time();
            
            att_est_last_gyro_time = n_r3;
            
            int64_t n_cse1 = (int64_t) (n_r3 - n_deref2);
            int64_t n_cse5 = (int64_t) (n_cse1 / (int64_t) 1000);
            int64_t n_cse9 = (int64_t) ((bool) ((int64_t) (n_cse1 % (int64_t) 1000) < (int64_t) 0) ? (int64_t) (n_cse5 - (int64_t) 1) : n_cse5);
            
            att_est_ahrs_mlkf_propagate(&att_est_last_gyro_rads, (float) ((float) (int16_t) ((bool) ((bool) (n_cse9 <= (int64_t) INT16_MAX) && (bool) (n_cse9 >= (int64_t) INT16_MIN)) ? (int16_t) n_cse9 : (int16_t) 0) / 1000.0f));
            emitter_att_est_gyro_chan_189(&att_est_ahrs_state);
        } else {
            bool n_deref4 = in_motion;
            
            if ((bool) !n_deref4) {
                bool n_r5 = att_est_ahrs_mlkf_align(&att_est_last_gyro_rads, &att_est_last_acc, &att_est_last_mag);
                
                if (n_r5) {
                    att_est_aligned = true;
                }
            }
        }
    }
}

void callback_att_est_accel_thread_period_5ms(const struct accelerometer_sample *n_var0)
{
    bool n_deref0 = n_var0->samplefail;
    
    if ((bool) !n_deref0) {
        att_est_last_acc = *n_var0;
        
        bool n_deref1 = att_est_aligned;
        
        if (n_deref1) {
            att_est_ahrs_mlkf_update_accel(n_var0);
            emitter_att_est_accel_chan_189(&att_est_ahrs_state);
        }
    }
}

void callback_write_gyro_output_attr_thread_period_5ms(const struct gyroscope_sample *n_var0)
{
    emitter_write_gyro_output_attr_chan_30(n_var0);
}

void callback_write_accel_output_attr_thread_period_5ms(const struct accelerometer_sample *n_var0)
{
    emitter_write_accel_output_attr_chan_31(n_var0);
}

void callback_motion_light_debug_2_thread_period_5ms(const bool *n_var0)
{
    bool n_deref0 = *n_var0;
    struct rgb_led_setting n_local1 = {};
    struct rgb_led_setting *n_ref2 = &n_local1;
    
    if (n_deref0) {
        n_ref2->red = (uint8_t) 15U;
    } else {
        n_ref2->green = (uint8_t) 15U;
    }
    emitter_motion_light_debug_2_chan_23(n_ref2);
}

void callback_detectMotion_2_accel_thread_period_5ms(const struct accelerometer_sample *n_var0)
{
    const struct xyz *n_cse0 = &n_var0->sample;
    float n_deref0 = n_cse0->x;
    float n_deref1 = n_cse0->y;
    float n_deref2 = n_cse0->z;
    float n_let3 = (float) (n_deref0 / 2.5553503f);
    float n_deref4 = detectMotion_2_ax_butter_state_x1;
    float n_deref5 = detectMotion_2_ax_butter_state_x0;
    float n_deref6 = detectMotion_2_ax_butter_state_y1;
    float n_deref7 = detectMotion_2_ax_butter_state_y0;
    float n_let8 = (float) ((float) ((float) ((float) (n_let3 + (float) (-2.0f * n_deref5)) + n_deref4) + (float) (0.36952737f * n_deref7)) + (float) (-0.19481471f * n_deref6));
    
    detectMotion_2_ax_butter_state_x0 = n_let3;
    detectMotion_2_ax_butter_state_x1 = n_deref5;
    detectMotion_2_ax_butter_state_y0 = n_let8;
    detectMotion_2_ax_butter_state_y1 = n_deref7;
    
    float n_let9 = (float) (n_deref1 / 2.5553503f);
    float n_deref10 = detectMotion_2_ay_butter_state_x1;
    float n_deref11 = detectMotion_2_ay_butter_state_x0;
    float n_deref12 = detectMotion_2_ay_butter_state_y1;
    float n_deref13 = detectMotion_2_ay_butter_state_y0;
    float n_let14 = (float) ((float) ((float) ((float) (n_let9 + (float) (-2.0f * n_deref11)) + n_deref10) + (float) (0.36952737f * n_deref13)) + (float) (-0.19481471f * n_deref12));
    
    detectMotion_2_ay_butter_state_x0 = n_let9;
    detectMotion_2_ay_butter_state_x1 = n_deref11;
    detectMotion_2_ay_butter_state_y0 = n_let14;
    detectMotion_2_ay_butter_state_y1 = n_deref13;
    
    float n_let15 = (float) (n_deref2 / 2.5553503f);
    float n_deref16 = detectMotion_2_az_butter_state_x1;
    float n_deref17 = detectMotion_2_az_butter_state_x0;
    float n_deref18 = detectMotion_2_az_butter_state_y1;
    float n_deref19 = detectMotion_2_az_butter_state_y0;
    float n_let20 = (float) ((float) ((float) ((float) (n_let15 + (float) (-2.0f * n_deref17)) + n_deref16) + (float) (0.36952737f * n_deref19)) + (float) (-0.19481471f * n_deref18));
    
    detectMotion_2_az_butter_state_x0 = n_let15;
    detectMotion_2_az_butter_state_x1 = n_deref17;
    detectMotion_2_az_butter_state_y0 = n_let20;
    detectMotion_2_az_butter_state_y1 = n_deref19;
    
    float n_deref21 = detectMotion_2_ax_butter_state_y0;
    float n_deref22 = detectMotion_2_ay_butter_state_y0;
    float n_deref23 = detectMotion_2_az_butter_state_y0;
    float n_let24 = (float) ((float) ((float) ((float) (n_deref21 * n_deref21) + (float) (n_deref22 * n_deref22)) + (float) (n_deref23 * n_deref23)) - 96.17039f);
    
    if ((bool) (n_let24 > 0.25f)) {
        accel_threshold_counter = (uint32_t) 0U;
    } else {
        uint32_t n_deref25 = accel_threshold_counter;
        
        accel_threshold_counter = (uint32_t) (n_deref25 + (uint32_t) 1U);
    }
    
    uint32_t n_deref26 = accel_threshold_counter;
    uint32_t n_deref27 = gyro_threshold_counter;
    bool n_local28 = (bool) ((bool) (n_deref26 <= (uint32_t) 200U) || (bool) (n_deref27 <= (uint32_t) 200U));
    bool *n_ref29 = &n_local28;
    
    emitter_detectMotion_2_accel_chan_188(n_ref29);
}

void callback_detectMotion_2_gyro_thread_period_5ms(const struct gyroscope_sample *n_var0)
{
    const struct xyz *n_cse0 = &n_var0->sample;
    float n_deref0 = n_cse0->x;
    float n_deref1 = n_cse0->y;
    float n_deref2 = n_cse0->z;
    float n_let3 = (float) (n_deref0 / 2.5553503f);
    float n_deref4 = detectMotion_2_gx_butter_state_x1;
    float n_deref5 = detectMotion_2_gx_butter_state_x0;
    float n_deref6 = detectMotion_2_gx_butter_state_y1;
    float n_deref7 = detectMotion_2_gx_butter_state_y0;
    float n_let8 = (float) ((float) ((float) ((float) (n_let3 + (float) (-2.0f * n_deref5)) + n_deref4) + (float) (0.36952737f * n_deref7)) + (float) (-0.19481471f * n_deref6));
    
    detectMotion_2_gx_butter_state_x0 = n_let3;
    detectMotion_2_gx_butter_state_x1 = n_deref5;
    detectMotion_2_gx_butter_state_y0 = n_let8;
    detectMotion_2_gx_butter_state_y1 = n_deref7;
    
    float n_let9 = (float) (n_deref1 / 2.5553503f);
    float n_deref10 = detectMotion_2_gy_butter_state_x1;
    float n_deref11 = detectMotion_2_gy_butter_state_x0;
    float n_deref12 = detectMotion_2_gy_butter_state_y1;
    float n_deref13 = detectMotion_2_gy_butter_state_y0;
    float n_let14 = (float) ((float) ((float) ((float) (n_let9 + (float) (-2.0f * n_deref11)) + n_deref10) + (float) (0.36952737f * n_deref13)) + (float) (-0.19481471f * n_deref12));
    
    detectMotion_2_gy_butter_state_x0 = n_let9;
    detectMotion_2_gy_butter_state_x1 = n_deref11;
    detectMotion_2_gy_butter_state_y0 = n_let14;
    detectMotion_2_gy_butter_state_y1 = n_deref13;
    
    float n_let15 = (float) (n_deref2 / 2.5553503f);
    float n_deref16 = detectMotion_2_gz_butter_state_x1;
    float n_deref17 = detectMotion_2_gz_butter_state_x0;
    float n_deref18 = detectMotion_2_gz_butter_state_y1;
    float n_deref19 = detectMotion_2_gz_butter_state_y0;
    float n_let20 = (float) ((float) ((float) ((float) (n_let15 + (float) (-2.0f * n_deref17)) + n_deref16) + (float) (0.36952737f * n_deref19)) + (float) (-0.19481471f * n_deref18));
    
    detectMotion_2_gz_butter_state_x0 = n_let15;
    detectMotion_2_gz_butter_state_x1 = n_deref17;
    detectMotion_2_gz_butter_state_y0 = n_let20;
    detectMotion_2_gz_butter_state_y1 = n_deref19;
    
    float n_deref21 = detectMotion_2_gx_butter_state_y0;
    float n_deref22 = detectMotion_2_gy_butter_state_y0;
    float n_deref23 = detectMotion_2_gz_butter_state_y0;
    float n_let24 = (float) ((float) ((float) (n_deref21 * n_deref21) + (float) (n_deref22 * n_deref22)) + (float) (n_deref23 * n_deref23));
    
    if ((bool) (n_let24 > 0.25f)) {
        gyro_threshold_counter = (uint32_t) 0U;
    } else {
        uint32_t n_deref25 = gyro_threshold_counter;
        
        gyro_threshold_counter = (uint32_t) (n_deref25 + (uint32_t) 1U);
    }
}

void callback_spi1_scheduler_mpu6000_thread_period_5ms(const struct spi_transaction_request *n_var0)
{
    bool n_deref0 = spi1_scheduler_mpu6000_pending;
    
    ASSERTS((bool) !n_deref0);
    spi1_scheduler_mpu6000_last_req = *n_var0;
    spi1_scheduler_mpu6000_pending = true;
    
    uint32_t n_deref1 = spi1_scheduler_response_task;
    
    if ((bool) (0 == n_deref1)) {
        spi1_scheduler_response_task = (uint32_t) 1U;
        emitter_spi1_scheduler_mpu6000_chan_158(&spi1_scheduler_mpu6000_last_req);
    }
}

void callback_period_thread_period_5ms(const int64_t *n_var0)
{
    /* samplePeriodMS = Milliseconds 5 */
    ;
    
    bool n_deref0 = ready;
    bool n_deref1 = transaction_pending;
    
    if ((bool) !n_deref0) {
        gyro.initfail = true;
        accel.initfail = true;
        
        int64_t n_r2 = tower_get_time();
        
        gyro.samplefail = true;
        
        struct xyz *n_cse4 = &gyro.sample;
        
        n_cse4->x = 0.0f;
        n_cse4->y = 0.0f;
        n_cse4->z = 0.0f;
        gyro.temperature = 0.0f;
        gyro.time = n_r2;
        accel.samplefail = true;
        
        struct xyz *n_cse11 = &accel.sample;
        
        n_cse11->x = 0.0f;
        n_cse11->y = 0.0f;
        n_cse11->z = 0.0f;
        accel.temperature = 0.0f;
        accel.time = n_r2;
        emitter_period_chan_157(&gyro);
        emitter_period_chan_156(&accel);
    } else {
        if (n_deref1) {
            int64_t n_r3 = tower_get_time();
            
            gyro.samplefail = true;
            
            struct xyz *n_cse18 = &gyro.sample;
            
            n_cse18->x = 0.0f;
            n_cse18->y = 0.0f;
            n_cse18->z = 0.0f;
            gyro.temperature = 0.0f;
            gyro.time = n_r3;
            accel.samplefail = true;
            
            struct xyz *n_cse25 = &accel.sample;
            
            n_cse25->x = 0.0f;
            n_cse25->y = 0.0f;
            n_cse25->z = 0.0f;
            accel.temperature = 0.0f;
            accel.time = n_r3;
            emitter_period_chan_157(&gyro);
            emitter_period_chan_156(&accel);
        } else {
            gyro.initfail = false;
            accel.initfail = false;
            transaction_pending = true;
            
            struct spi_transaction_request n_local4 = {.tx_device =(uint8_t) 0U, .tx_buf ={(uint8_t) 187U}, .tx_len =(int32_t) 15};
            struct spi_transaction_request *n_ref5 = &n_local4;
            
            emitter_period_chan_167(n_ref5);
        }
    }
}

void callback_request_4_thread_period_5ms(const struct spi_transaction_request *n_var0)
{
    bool n_deref0 = done;
    
    if (n_deref0) {
        done = false;
        reqbuffer = *n_var0;
        
        int32_t n_deref1 = reqbuffer.tx_len;
        
        reqbufferpos = (int32_t) 0;
        resbufferpos = (int32_t) 0;
        resbuffer.rx_idx = n_deref1;
        
        uint8_t n_deref2 = reqbuffer.tx_buf[(int32_t) 0];
        
        reqbufferpos = (int32_t) 1;
        /* selecting device: */
        ;
        
        uint8_t n_deref3 = reqbuffer.tx_device;
        
        ASSERTS((bool) (n_deref3 < (uint8_t) 4U));
        if ((bool) (0 == n_deref3)) {
            mpu6k_devicebegin();
        } else {
            if ((bool) ((uint8_t) 1U == n_deref3)) {
                lsm303d_devicebegin();
            } else {
                if ((bool) ((uint8_t) 2U == n_deref3)) {
                    ms5611_devicebegin();
                } else {
                    if ((bool) (n_deref3 == (uint8_t) 3U)) {
                        l3gd20_devicebegin();
                    }
                }
            }
        }
        /* end selecting configured device */
        ;
        /* reg set spi1->dr: setField spi_dr_data */
        ;
        ivory_hw_io_write_u16((uint32_t) 1073819660U, (uint16_t) ((uint16_t) n_deref2 << 0));
        
        uint16_t n_r4 = ivory_hw_io_read_u16((uint32_t) 1073819652U);
        
        /* reg modify spi1->cr2: setBit spi_cr2_txeie */
        ;
        ivory_hw_io_write_u16((uint32_t) 1073819652U, (uint16_t) (n_r4 | (uint16_t) ((uint16_t) 1U << (uint16_t) 7U)));
    }
}

void callback_accel_output_attr_update_thread_period_5ms(const struct accelerometer_sample *n_var0)
{
    accel_output_attr = *n_var0;
}

void callback_gyro_output_attr_update_thread_period_5ms(const struct gyroscope_sample *n_var0)
{
    gyro_output_attr = *n_var0;
}

void callback_sensors_output_attr_update_thread_period_5ms(const struct sensors_result *n_var0)
{
    sensors_output_attr = *n_var0;
}

void callback_rgb_led_attr_update_thread_period_5ms(const struct rgb_led_setting *n_var0)
{
    rgb_led_attr = *n_var0;
}

void emitter_set_chan_190(const struct i2c_transaction_request *n_var0)
{
    emitter_set_chan_190_thread_period_5ms_emit(n_var0);
}

void emitter_i2c2_request_chan_191(const struct i2c_transaction_result *n_var0)
{
    emitter_i2c2_request_chan_191_thread_period_5ms_emit(n_var0);
}

void emitter_new_state_chan_29(const struct sensors_result *n_var0)
{
    emitter_new_state_chan_29_thread_period_5ms_emit(n_var0);
}

void emitter_att_est_gyro_chan_189(const struct AhrsMlkf *n_var0)
{
    emitter_att_est_gyro_chan_189_thread_period_5ms_emit(n_var0);
}

void emitter_att_est_accel_chan_189(const struct AhrsMlkf *n_var0)
{
    emitter_att_est_accel_chan_189_thread_period_5ms_emit(n_var0);
}

void emitter_write_gyro_output_attr_chan_30(const struct gyroscope_sample *n_var0)
{
    emitter_write_gyro_output_attr_chan_30_thread_period_5ms_emit(n_var0);
}

void emitter_write_accel_output_attr_chan_31(const struct accelerometer_sample *n_var0)
{
    emitter_write_accel_output_attr_chan_31_thread_period_5ms_emit(n_var0);
}

void emitter_motion_light_debug_2_chan_23(const struct rgb_led_setting *n_var0)
{
    emitter_motion_light_debug_2_chan_23_thread_period_5ms_emit(n_var0);
}

void emitter_detectMotion_2_accel_chan_188(const bool *n_var0)
{
    emitter_detectMotion_2_accel_chan_188_thread_period_5ms_emit(n_var0);
}

void emitter_spi1_scheduler_mpu6000_chan_158(const struct spi_transaction_request *n_var0)
{
    emitter_spi1_scheduler_mpu6000_chan_158_thread_period_5ms_emit(n_var0);
}

void emitter_period_chan_167(const struct spi_transaction_request *n_var0)
{
    emitter_period_chan_167_thread_period_5ms_emit(n_var0);
}

void emitter_period_chan_157(const struct gyroscope_sample *n_var0)
{
    emitter_period_chan_157_thread_period_5ms_emit(n_var0);
}

void emitter_period_chan_156(const struct accelerometer_sample *n_var0)
{
    emitter_period_chan_156_thread_period_5ms_emit(n_var0);
}
