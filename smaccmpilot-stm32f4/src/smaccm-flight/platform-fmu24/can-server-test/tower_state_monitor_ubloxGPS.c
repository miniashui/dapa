/* This file has been autogenerated by Ivory
 * Compiler version  0.1.0.5
 */
#include "tower_state_monitor_ubloxGPS.h"

uint32_t decodestate = (uint32_t) 0U;

uint8_t pktClass;

uint8_t pktId;

uint16_t pktLen;

uint16_t payOffs;

uint8_t payload[52U];

struct position_sample position_1;

uint8_t decode_state;

uint8_t ck_a;

uint8_t ck_b;

void ublox_decode(uint8_t *n_var0, uint8_t n_var1, uint8_t n_var2, uint8_t n_var3[52U], uint16_t n_var4, struct position_sample *n_var5)
{
    uint8_t n_deref0 = *n_var0;
    bool n_cse0 = (bool) (n_var1 == (uint8_t) 1U);
    
    if ((bool) (n_cse0 && (bool) ((bool) ((uint8_t) 2U == n_var2) && (bool) (n_var4 == (uint16_t) 28U)))) {
        *n_var0 = (uint8_t) (n_deref0 | (uint8_t) 2U);
        
        int32_t n_r1 = unpackS4(n_var3, (int32_t) 4);
        
        n_var5->lat = n_r1;
        
        int32_t n_r2 = unpackS4(n_var3, (int32_t) 8);
        
        n_var5->lon = n_r2;
        
        int32_t n_r3 = unpackS4(n_var3, (int32_t) 12);
        
        n_var5->alt = n_r3;
    } else {
        if ((bool) (n_cse0 && (bool) ((bool) (n_var2 == (uint8_t) 6U) && (bool) (n_var4 == (uint16_t) 52U)))) {
            *n_var0 = (uint8_t) (n_deref0 | (uint8_t) 1U);
            
            uint8_t n_deref4 = n_var3[(int32_t) 10];
            uint8_t n_deref5 = n_var3[(int32_t) 11];
            
            n_var5->fix = (uint8_t) ((bool) ((uint8_t) (n_deref5 & (uint8_t) 1U) > 0) ? (uint8_t) ((bool) (n_deref4 == (uint8_t) 3U) ? (uint8_t) 3U : (uint8_t) ((bool) ((uint8_t) 2U == n_deref4) ? (uint8_t) 2U : 0)) : 0);
            
            uint8_t n_deref6 = n_var3[(int32_t) 44];
            uint8_t n_deref7 = n_var3[(int32_t) 45];
            uint16_t n_let8 = (uint16_t) ((uint16_t) n_deref6 + (uint16_t) ((uint16_t) 256U * (uint16_t) n_deref7));
            
            n_var5->dop = (float) (1.0e-2f * (float) n_let8);
            
            uint8_t n_deref9 = n_var3[(int32_t) 47];
            
            n_var5->num_sv = n_deref9;
        } else {
            if ((bool) (n_cse0 && (bool) ((bool) (n_var2 == (uint8_t) 18U) && (bool) (n_var4 == (uint16_t) 36U)))) {
                *n_var0 = (uint8_t) (n_deref0 | (uint8_t) 4U);
                
                int32_t n_r10 = unpackS4(n_var3, (int32_t) 4);
                int32_t n_r11 = unpackS4(n_var3, (int32_t) 8);
                int32_t n_r12 = unpackS4(n_var3, (int32_t) 12);
                int32_t n_r13 = unpackS4(n_var3, (int32_t) 16);
                int32_t n_r14 = unpackS4(n_var3, (int32_t) 24);
                
                n_var5->vnorth = n_r10;
                n_var5->veast = n_r11;
                n_var5->vdown = n_r12;
                n_var5->vground = (uint32_t) ((bool) (n_r13 > (int32_t) 0) ? (uint32_t) n_r13 : 0);
                n_var5->heading = (float) ((float) n_r14 / 100000.0f);
            }
        }
    }
}

int32_t unpackS4(uint8_t n_var0[52U], int32_t n_var1)
{
    uint8_t n_deref0 = n_var0[n_var1 % 52];
    uint8_t n_deref1 = n_var0[(int32_t) (n_var1 + (int32_t) 1) % 52];
    uint8_t n_deref2 = n_var0[(int32_t) ((int32_t) 2 + n_var1) % 52];
    uint8_t n_deref3 = n_var0[(int32_t) (n_var1 + (int32_t) 3) % 52];
    uint32_t n_let4 = (uint32_t) ((uint32_t) ((uint32_t) ((uint32_t) ((uint32_t) 16777216U * (uint32_t) n_deref3) + (uint32_t) ((uint32_t) 65536U * (uint32_t) n_deref2)) + (uint32_t) ((uint32_t) 256U * (uint32_t) n_deref1)) + (uint32_t) n_deref0);
    uint64_t n_let5 = (uint64_t) ((uint64_t) 4294967296U - (uint64_t) n_let4);
    int64_t n_let6 = (int64_t) ((bool) (n_let5 <= (uint64_t) INT64_MAX) ? (int64_t) n_let5 : (int64_t) 0);
    
    return (int32_t) ((bool) (n_let4 < (uint32_t) 2147483647U) ? (int32_t) ((bool) (n_let4 <= (uint32_t) INT32_MAX) ? (int32_t) n_let4 : (int32_t) 0) : (int32_t) -((int32_t) ((bool) ((bool) (n_let6 <= (int64_t) INT32_MAX) && (bool) (n_let6 >= (int64_t) INT32_MIN)) ? (int32_t) n_let6 : (int32_t) 0)));
}
