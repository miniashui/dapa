/* This file has been autogenerated by Ivory
 * Compiler version  0.1.0.5
 */
#include "tower_gen_thread_init.h"

static struct i2c_transaction_request emitter_set_chan_190_thread_init_message_0;

static uint32_t emitter_set_chan_190_thread_init_message_count;

static struct i2c_transaction_result emitter_i2c2_request_chan_191_thread_init_message_0;

static uint32_t emitter_i2c2_request_chan_191_thread_init_message_count;

static int64_t emitter_dmauart_hw_init_chan_151_thread_init_message_0;

static uint32_t emitter_dmauart_hw_init_chan_151_thread_init_message_count;

static struct sensors_result emitter_new_state_chan_29_thread_init_message_0;

static uint32_t emitter_new_state_chan_29_thread_init_message_count;

static struct AhrsMlkf emitter_att_est_gyro_chan_189_thread_init_message_0;

static uint32_t emitter_att_est_gyro_chan_189_thread_init_message_count;

static struct AhrsMlkf emitter_att_est_mag_chan_189_thread_init_message_0;

static uint32_t emitter_att_est_mag_chan_189_thread_init_message_count;

static struct AhrsMlkf emitter_att_est_accel_chan_189_thread_init_message_0;

static uint32_t emitter_att_est_accel_chan_189_thread_init_message_count;

static struct magnetometer_sample emitter_write_mag_output_attr_chan_34_thread_init_message_0;

static uint32_t emitter_write_mag_output_attr_chan_34_thread_init_message_count;

static struct gyroscope_sample emitter_write_gyro_output_attr_chan_30_thread_init_message_0;

static uint32_t emitter_write_gyro_output_attr_chan_30_thread_init_message_count;

static struct barometer_sample emitter_write_baro_output_attr_chan_32_thread_init_message_0;

static uint32_t emitter_write_baro_output_attr_chan_32_thread_init_message_count;

static struct accelerometer_sample emitter_write_accel_output_attr_chan_31_thread_init_message_0;

static uint32_t emitter_write_accel_output_attr_chan_31_thread_init_message_count;

static struct rgb_led_setting emitter_motion_light_debug_2_chan_23_thread_init_message_0;

static uint32_t emitter_motion_light_debug_2_chan_23_thread_init_message_count;

static bool emitter_detectMotion_2_accel_chan_188_thread_init_message_0;

static uint32_t emitter_detectMotion_2_accel_chan_188_thread_init_message_count;

static struct spi_transaction_request emitter_spi1_scheduler_ready_chan_158_thread_init_message_0;

static uint32_t emitter_spi1_scheduler_ready_chan_158_thread_init_message_count;

static struct spi_transaction_request emitter_spi1_scheduler_l3gd20_chan_158_thread_init_message_0;

static uint32_t emitter_spi1_scheduler_l3gd20_chan_158_thread_init_message_count;

static struct spi_transaction_request emitter_spi1_scheduler_ms5611_chan_158_thread_init_message_0;

static uint32_t emitter_spi1_scheduler_ms5611_chan_158_thread_init_message_count;

static struct spi_transaction_request emitter_spi1_scheduler_lsm303d_chan_158_thread_init_message_0;

static uint32_t emitter_spi1_scheduler_lsm303d_chan_158_thread_init_message_count;

static struct spi_transaction_request emitter_spi1_scheduler_mpu6000_chan_158_thread_init_message_0;

static uint32_t emitter_spi1_scheduler_mpu6000_chan_158_thread_init_message_count;

static bool emitter_ms5611_init_chan_178_thread_init_message_0;

static uint32_t emitter_ms5611_init_chan_178_thread_init_message_count;

static struct spi_transaction_request emitter_ms5611_chan_175_thread_init_message_0;

static uint32_t emitter_ms5611_chan_175_thread_init_message_count;

static struct barometer_sample emitter_ms5611_chan_177_thread_init_message_0;

static uint32_t emitter_ms5611_chan_177_thread_init_message_count;

static bool emitter_lsm303d_coroutine_init_chan_174_thread_init_message_0;

static uint32_t emitter_lsm303d_coroutine_init_chan_174_thread_init_message_count;

static struct spi_transaction_request emitter_lsm303d_coroutine_chan_170_thread_init_message_0;

static uint32_t emitter_lsm303d_coroutine_chan_170_thread_init_message_count;

static struct magnetometer_sample emitter_lsm303d_coroutine_chan_172_thread_init_message_0;

static uint32_t emitter_lsm303d_coroutine_chan_172_thread_init_message_count;

static bool emitter_mpu6000_init_chan_169_thread_init_message_0;

static uint32_t emitter_mpu6000_init_chan_169_thread_init_message_count;

static struct spi_transaction_request emitter_mpu6000_chan_167_thread_init_message_0;

static uint32_t emitter_mpu6000_chan_167_thread_init_message_count;

static struct gyroscope_sample emitter_mpu6000_chan_157_thread_init_message_0;

static uint32_t emitter_mpu6000_chan_157_thread_init_message_count;

static struct accelerometer_sample emitter_mpu6000_chan_156_thread_init_message_0;

static uint32_t emitter_mpu6000_chan_156_thread_init_message_count;

static bool emitter_l3gd20_init_chan_166_thread_init_message_0;

static uint32_t emitter_l3gd20_init_chan_166_thread_init_message_count;

static struct spi_transaction_request emitter_l3gd20_chan_164_thread_init_message_0;

static uint32_t emitter_l3gd20_chan_164_thread_init_message_count;

static int64_t emitter_l3gd20_chan_162_thread_init_message_0;

static uint32_t emitter_l3gd20_chan_162_thread_init_message_count;

static int64_t emitter_init_2_chan_161_thread_init_message_0;

static uint32_t emitter_init_2_chan_161_thread_init_message_count;

static int64_t emitter_initialize_hardware_chan_160_thread_init_message_0;

static uint32_t emitter_initialize_hardware_chan_160_thread_init_message_count;

static struct position_sample emitter_write_gps_output_attr_chan_37_thread_init_message_0;

static uint32_t emitter_write_gps_output_attr_chan_37_thread_init_message_count;

static struct position_sample emitter_ublox_init_chan_147_thread_init_message_0;

static uint32_t emitter_ublox_init_chan_147_thread_init_message_count;

static void handler_run_i2c_response_thread_init(const struct i2c_transaction_result *n_var0);

static void handler_run_set_thread_init(const struct rgb_led_setting *n_var0);

static void handler_run_i2c2_request_thread_init(const struct i2c_transaction_request *n_var0);

static void handler_run_i2c2_init_thread_init(const int64_t *n_var0);

static void handler_run_dmauart_rx_init_thread_init(const int64_t *n_var0);

static void handler_run_dmauart_tx_init_thread_init(const int64_t *n_var0);

static void handler_run_dmauart_hw_init_thread_init(const int64_t *n_var0);

static void handler_run_new_state_thread_init(const struct AhrsMlkf *n_var0);

static void handler_run_save_last_gyro_thread_init(const struct gyroscope_sample *n_var0);

static void handler_run_save_last_baro_thread_init(const struct barometer_sample *n_var0);

static void handler_run_save_last_mag_thread_init(const struct magnetometer_sample *n_var0);

static void handler_run_save_last_accel_thread_init(const struct accelerometer_sample *n_var0);

static void handler_run_att_est_motion_thread_init(const bool *n_var0);

static void handler_run_att_est_gyro_thread_init(const struct gyroscope_sample *n_var0);

static void handler_run_att_est_mag_thread_init(const struct magnetometer_sample *n_var0);

static void handler_run_att_est_accel_thread_init(const struct accelerometer_sample *n_var0);

static void handler_run_att_est_init_thread_init(const int64_t *n_var0);

static void handler_run_write_mag_output_attr_thread_init(const struct magnetometer_sample *n_var0);

static void handler_run_write_gyro_output_attr_thread_init(const struct gyroscope_sample *n_var0);

static void handler_run_write_baro_output_attr_thread_init(const struct barometer_sample *n_var0);

static void handler_run_write_accel_output_attr_thread_init(const struct accelerometer_sample *n_var0);

static void handler_run_motion_light_debug_2_thread_init(const bool *n_var0);

static void handler_run_detectMotion_2_accel_thread_init(const struct accelerometer_sample *n_var0);

static void handler_run_detectMotion_2_gyro_thread_init(const struct gyroscope_sample *n_var0);

static void handler_run_detectMotion_2_init_thread_init(const int64_t *n_var0);

static void handler_run_i2c1_init_thread_init(const int64_t *n_var0);

static void handler_run_spi1_scheduler_ready_thread_init(const int64_t *n_var0);

static void handler_run_spi1_scheduler_l3gd20_thread_init(const struct spi_transaction_request *n_var0);

static void handler_run_spi1_scheduler_ms5611_thread_init(const struct spi_transaction_request *n_var0);

static void handler_run_spi1_scheduler_lsm303d_thread_init(const struct spi_transaction_request *n_var0);

static void handler_run_spi1_scheduler_mpu6000_thread_init(const struct spi_transaction_request *n_var0);

static void handler_run_ms5611_init_thread_init(const int64_t *n_var0);

static void handler_run_ms5611_thread_init(const bool *n_var0);

static void handler_run_lsm303d_coroutine_init_thread_init(const int64_t *n_var0);

static void handler_run_lsm303d_coroutine_thread_init(const bool *n_var0);

static void handler_run_mpu6000_init_thread_init(const int64_t *n_var0);

static void handler_run_mpu6000_thread_init(const bool *n_var0);

static void handler_run_l3gd20_init_thread_init(const int64_t *n_var0);

static void handler_run_l3gd20_thread_init(const bool *n_var0);

static void handler_run_init_2_thread_init(const int64_t *n_var0);

static void handler_run_request_4_thread_init(const struct spi_transaction_request *n_var0);

static void handler_run_initialize_hardware_thread_init(const int64_t *n_var0);

static void handler_run_write_gps_output_attr_thread_init(const struct position_sample *n_var0);

static void handler_run_ublox_init_thread_init(const int64_t *n_var0);

static void handler_run_gps_output_attr_update_thread_init(const struct position_sample *n_var0);

static void handler_run_mag_output_attr_update_thread_init(const struct magnetometer_sample *n_var0);

static void handler_run_baro_output_attr_update_thread_init(const struct barometer_sample *n_var0);

static void handler_run_accel_output_attr_update_thread_init(const struct accelerometer_sample *n_var0);

static void handler_run_gyro_output_attr_update_thread_init(const struct gyroscope_sample *n_var0);

static void handler_run_sensors_output_attr_update_thread_init(const struct sensors_result *n_var0);

static void handler_run_rgb_led_attr_update_thread_init(const struct rgb_led_setting *n_var0);

static void handler_run_can_init_2_thread_init(const int64_t *n_var0);

static void handler_run_init_thread_init(const int64_t *n_var0);

void loop_thread_init(void)
{
    int64_t n_local0 = (int64_t) 0;
    int64_t *n_ref1 = &n_local0;
    bool n_cse1 = (bool) ((uint8_t) 12U < (uint8_t) ((uint8_t) 1U << (uint8_t) 4U));
    
    ASSERTS(n_cse1);
    
    uint8_t n_cse2 = (uint8_t) ((uint8_t) 12U << (uint8_t) 4U);
    
    ivory_hw_io_write_u8((uint32_t) 3758154771U, n_cse2);
    ASSERTS(n_cse1);
    ivory_hw_io_write_u8((uint32_t) 3758154772U, n_cse2);
    ASSERTS(n_cse1);
    ivory_hw_io_write_u8((uint32_t) 3758154773U, n_cse2);
    ASSERTS(n_cse1);
    ivory_hw_io_write_u8((uint32_t) 3758154767U, n_cse2);
    ASSERTS(n_cse1);
    ivory_hw_io_write_u8((uint32_t) 3758154765U, n_cse2);
    ASSERTS(n_cse1);
    ivory_hw_io_write_u8((uint32_t) 3758154787U, n_cse2);
    ASSERTS(n_cse1);
    ivory_hw_io_write_u8((uint32_t) 3758154783U, n_cse2);
    ASSERTS(n_cse1);
    ivory_hw_io_write_u8((uint32_t) 3758154784U, n_cse2);
    ASSERTS(n_cse1);
    ivory_hw_io_write_u8((uint32_t) 3758154785U, n_cse2);
    ASSERTS(n_cse1);
    ivory_hw_io_write_u8((uint32_t) 3758154786U, n_cse2);
    handler_run_init_thread_init(n_ref1);
    handler_run_can_init_2_thread_init(n_ref1);
    handler_run_ublox_init_thread_init(n_ref1);
    handler_run_initialize_hardware_thread_init(n_ref1);
    handler_run_i2c1_init_thread_init(n_ref1);
    handler_run_detectMotion_2_init_thread_init(n_ref1);
    handler_run_att_est_init_thread_init(n_ref1);
    handler_run_dmauart_hw_init_thread_init(n_ref1);
    handler_run_i2c2_init_thread_init(n_ref1);
    return;
}

void emitter_set_chan_190_thread_init_emit(const struct i2c_transaction_request *n_var0)
{
    uint32_t n_deref0 = emitter_set_chan_190_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_set_chan_190_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_set_chan_190_thread_init_message_0 = *n_var0;
    }
}

void emitter_i2c2_request_chan_191_thread_init_emit(const struct i2c_transaction_result *n_var0)
{
    uint32_t n_deref0 = emitter_i2c2_request_chan_191_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_i2c2_request_chan_191_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_i2c2_request_chan_191_thread_init_message_0 = *n_var0;
    }
}

void emitter_dmauart_hw_init_chan_151_thread_init_emit(const int64_t *n_var0)
{
    uint32_t n_deref0 = emitter_dmauart_hw_init_chan_151_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_dmauart_hw_init_chan_151_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_dmauart_hw_init_chan_151_thread_init_message_0 = *n_var0;
    }
}

void emitter_new_state_chan_29_thread_init_emit(const struct sensors_result *n_var0)
{
    uint32_t n_deref0 = emitter_new_state_chan_29_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_new_state_chan_29_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_new_state_chan_29_thread_init_message_0 = *n_var0;
    }
}

void emitter_att_est_gyro_chan_189_thread_init_emit(const struct AhrsMlkf *n_var0)
{
    uint32_t n_deref0 = emitter_att_est_gyro_chan_189_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_att_est_gyro_chan_189_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_att_est_gyro_chan_189_thread_init_message_0 = *n_var0;
    }
}

void emitter_att_est_mag_chan_189_thread_init_emit(const struct AhrsMlkf *n_var0)
{
    uint32_t n_deref0 = emitter_att_est_mag_chan_189_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_att_est_mag_chan_189_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_att_est_mag_chan_189_thread_init_message_0 = *n_var0;
    }
}

void emitter_att_est_accel_chan_189_thread_init_emit(const struct AhrsMlkf *n_var0)
{
    uint32_t n_deref0 = emitter_att_est_accel_chan_189_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_att_est_accel_chan_189_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_att_est_accel_chan_189_thread_init_message_0 = *n_var0;
    }
}

void emitter_write_mag_output_attr_chan_34_thread_init_emit(const struct magnetometer_sample *n_var0)
{
    uint32_t n_deref0 = emitter_write_mag_output_attr_chan_34_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_write_mag_output_attr_chan_34_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_write_mag_output_attr_chan_34_thread_init_message_0 = *n_var0;
    }
}

void emitter_write_gyro_output_attr_chan_30_thread_init_emit(const struct gyroscope_sample *n_var0)
{
    uint32_t n_deref0 = emitter_write_gyro_output_attr_chan_30_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_write_gyro_output_attr_chan_30_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_write_gyro_output_attr_chan_30_thread_init_message_0 = *n_var0;
    }
}

void emitter_write_baro_output_attr_chan_32_thread_init_emit(const struct barometer_sample *n_var0)
{
    uint32_t n_deref0 = emitter_write_baro_output_attr_chan_32_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_write_baro_output_attr_chan_32_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_write_baro_output_attr_chan_32_thread_init_message_0 = *n_var0;
    }
}

void emitter_write_accel_output_attr_chan_31_thread_init_emit(const struct accelerometer_sample *n_var0)
{
    uint32_t n_deref0 = emitter_write_accel_output_attr_chan_31_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_write_accel_output_attr_chan_31_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_write_accel_output_attr_chan_31_thread_init_message_0 = *n_var0;
    }
}

void emitter_motion_light_debug_2_chan_23_thread_init_emit(const struct rgb_led_setting *n_var0)
{
    uint32_t n_deref0 = emitter_motion_light_debug_2_chan_23_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_motion_light_debug_2_chan_23_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_motion_light_debug_2_chan_23_thread_init_message_0 = *n_var0;
    }
}

void emitter_detectMotion_2_accel_chan_188_thread_init_emit(const bool *n_var0)
{
    uint32_t n_deref0 = emitter_detectMotion_2_accel_chan_188_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_detectMotion_2_accel_chan_188_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_detectMotion_2_accel_chan_188_thread_init_message_0 = *n_var0;
    }
}

void emitter_spi1_scheduler_ready_chan_158_thread_init_emit(const struct spi_transaction_request *n_var0)
{
    uint32_t n_deref0 = emitter_spi1_scheduler_ready_chan_158_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_spi1_scheduler_ready_chan_158_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_spi1_scheduler_ready_chan_158_thread_init_message_0 = *n_var0;
    }
}

void emitter_spi1_scheduler_l3gd20_chan_158_thread_init_emit(const struct spi_transaction_request *n_var0)
{
    uint32_t n_deref0 = emitter_spi1_scheduler_l3gd20_chan_158_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_spi1_scheduler_l3gd20_chan_158_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_spi1_scheduler_l3gd20_chan_158_thread_init_message_0 = *n_var0;
    }
}

void emitter_spi1_scheduler_ms5611_chan_158_thread_init_emit(const struct spi_transaction_request *n_var0)
{
    uint32_t n_deref0 = emitter_spi1_scheduler_ms5611_chan_158_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_spi1_scheduler_ms5611_chan_158_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_spi1_scheduler_ms5611_chan_158_thread_init_message_0 = *n_var0;
    }
}

void emitter_spi1_scheduler_lsm303d_chan_158_thread_init_emit(const struct spi_transaction_request *n_var0)
{
    uint32_t n_deref0 = emitter_spi1_scheduler_lsm303d_chan_158_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_spi1_scheduler_lsm303d_chan_158_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_spi1_scheduler_lsm303d_chan_158_thread_init_message_0 = *n_var0;
    }
}

void emitter_spi1_scheduler_mpu6000_chan_158_thread_init_emit(const struct spi_transaction_request *n_var0)
{
    uint32_t n_deref0 = emitter_spi1_scheduler_mpu6000_chan_158_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_spi1_scheduler_mpu6000_chan_158_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_spi1_scheduler_mpu6000_chan_158_thread_init_message_0 = *n_var0;
    }
}

void emitter_ms5611_init_chan_178_thread_init_emit(const bool *n_var0)
{
    uint32_t n_deref0 = emitter_ms5611_init_chan_178_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_ms5611_init_chan_178_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_ms5611_init_chan_178_thread_init_message_0 = *n_var0;
    }
}

void emitter_ms5611_chan_175_thread_init_emit(const struct spi_transaction_request *n_var0)
{
    uint32_t n_deref0 = emitter_ms5611_chan_175_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_ms5611_chan_175_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_ms5611_chan_175_thread_init_message_0 = *n_var0;
    }
}

void emitter_ms5611_chan_177_thread_init_emit(const struct barometer_sample *n_var0)
{
    uint32_t n_deref0 = emitter_ms5611_chan_177_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_ms5611_chan_177_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_ms5611_chan_177_thread_init_message_0 = *n_var0;
    }
}

void emitter_lsm303d_coroutine_init_chan_174_thread_init_emit(const bool *n_var0)
{
    uint32_t n_deref0 = emitter_lsm303d_coroutine_init_chan_174_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_lsm303d_coroutine_init_chan_174_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_lsm303d_coroutine_init_chan_174_thread_init_message_0 = *n_var0;
    }
}

void emitter_lsm303d_coroutine_chan_170_thread_init_emit(const struct spi_transaction_request *n_var0)
{
    uint32_t n_deref0 = emitter_lsm303d_coroutine_chan_170_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_lsm303d_coroutine_chan_170_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_lsm303d_coroutine_chan_170_thread_init_message_0 = *n_var0;
    }
}

void emitter_lsm303d_coroutine_chan_172_thread_init_emit(const struct magnetometer_sample *n_var0)
{
    uint32_t n_deref0 = emitter_lsm303d_coroutine_chan_172_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_lsm303d_coroutine_chan_172_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_lsm303d_coroutine_chan_172_thread_init_message_0 = *n_var0;
    }
}

void emitter_mpu6000_init_chan_169_thread_init_emit(const bool *n_var0)
{
    uint32_t n_deref0 = emitter_mpu6000_init_chan_169_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_mpu6000_init_chan_169_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_mpu6000_init_chan_169_thread_init_message_0 = *n_var0;
    }
}

void emitter_mpu6000_chan_167_thread_init_emit(const struct spi_transaction_request *n_var0)
{
    uint32_t n_deref0 = emitter_mpu6000_chan_167_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_mpu6000_chan_167_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_mpu6000_chan_167_thread_init_message_0 = *n_var0;
    }
}

void emitter_mpu6000_chan_157_thread_init_emit(const struct gyroscope_sample *n_var0)
{
    uint32_t n_deref0 = emitter_mpu6000_chan_157_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_mpu6000_chan_157_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_mpu6000_chan_157_thread_init_message_0 = *n_var0;
    }
}

void emitter_mpu6000_chan_156_thread_init_emit(const struct accelerometer_sample *n_var0)
{
    uint32_t n_deref0 = emitter_mpu6000_chan_156_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_mpu6000_chan_156_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_mpu6000_chan_156_thread_init_message_0 = *n_var0;
    }
}

void emitter_l3gd20_init_chan_166_thread_init_emit(const bool *n_var0)
{
    uint32_t n_deref0 = emitter_l3gd20_init_chan_166_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_l3gd20_init_chan_166_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_l3gd20_init_chan_166_thread_init_message_0 = *n_var0;
    }
}

void emitter_l3gd20_chan_164_thread_init_emit(const struct spi_transaction_request *n_var0)
{
    uint32_t n_deref0 = emitter_l3gd20_chan_164_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_l3gd20_chan_164_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_l3gd20_chan_164_thread_init_message_0 = *n_var0;
    }
}

void emitter_l3gd20_chan_162_thread_init_emit(const int64_t *n_var0)
{
    uint32_t n_deref0 = emitter_l3gd20_chan_162_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_l3gd20_chan_162_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_l3gd20_chan_162_thread_init_message_0 = *n_var0;
    }
}

void emitter_init_2_chan_161_thread_init_emit(const int64_t *n_var0)
{
    uint32_t n_deref0 = emitter_init_2_chan_161_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_init_2_chan_161_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_init_2_chan_161_thread_init_message_0 = *n_var0;
    }
}

void emitter_initialize_hardware_chan_160_thread_init_emit(const int64_t *n_var0)
{
    uint32_t n_deref0 = emitter_initialize_hardware_chan_160_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_initialize_hardware_chan_160_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_initialize_hardware_chan_160_thread_init_message_0 = *n_var0;
    }
}

void emitter_write_gps_output_attr_chan_37_thread_init_emit(const struct position_sample *n_var0)
{
    uint32_t n_deref0 = emitter_write_gps_output_attr_chan_37_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_write_gps_output_attr_chan_37_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_write_gps_output_attr_chan_37_thread_init_message_0 = *n_var0;
    }
}

void emitter_ublox_init_chan_147_thread_init_emit(const struct position_sample *n_var0)
{
    uint32_t n_deref0 = emitter_ublox_init_chan_147_thread_init_message_count;
    
    if ((bool) (n_deref0 <= 0)) {
        emitter_ublox_init_chan_147_thread_init_message_count = (uint32_t) (n_deref0 + (uint32_t) 1U);
        emitter_ublox_init_chan_147_thread_init_message_0 = *n_var0;
    }
}

void handler_run_i2c_response_thread_init(const struct i2c_transaction_result *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_rgbled();
    /* run callbacks */
    callback_i2c_response_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_rgbled();
    /* deliver emitters */
    ;
}

void handler_run_set_thread_init(const struct rgb_led_setting *n_var0)
{
    /* init emitters */
    emitter_set_chan_190_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_rgbled();
    /* run callbacks */
    callback_set_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_rgbled();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_set_chan_190_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_i2c2_request_thread_init(&emitter_set_chan_190_thread_init_message_0);
    }
}

void handler_run_i2c2_request_thread_init(const struct i2c_transaction_request *n_var0)
{
    /* init emitters */
    emitter_i2c2_request_chan_191_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_i2c2PeripheralDriver();
    /* run callbacks */
    callback_i2c2_request_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_i2c2PeripheralDriver();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_i2c2_request_chan_191_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_i2c_response_thread_init(&emitter_i2c2_request_chan_191_thread_init_message_0);
    }
}

void handler_run_i2c2_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_i2c2PeripheralDriver();
    /* run callbacks */
    callback_i2c2_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_i2c2PeripheralDriver();
    /* deliver emitters */
    ;
}

void handler_run_dmauart_rx_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_uart_dma();
    /* run callbacks */
    callback_dmauart_rx_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_uart_dma();
    /* deliver emitters */
    ;
}

void handler_run_dmauart_tx_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_uart_dma();
    /* run callbacks */
    callback_dmauart_tx_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_uart_dma();
    /* deliver emitters */
    ;
}

void handler_run_dmauart_hw_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    emitter_dmauart_hw_init_chan_151_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_uart_dma();
    /* run callbacks */
    callback_dmauart_hw_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_uart_dma();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_dmauart_hw_init_chan_151_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_dmauart_tx_init_thread_init(&emitter_dmauart_hw_init_chan_151_thread_init_message_0);
        handler_run_dmauart_rx_init_thread_init(&emitter_dmauart_hw_init_chan_151_thread_init_message_0);
    }
}

void handler_run_new_state_thread_init(const struct AhrsMlkf *n_var0)
{
    /* init emitters */
    emitter_new_state_chan_29_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_sensor_fusion_proxy();
    /* run callbacks */
    callback_new_state_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_sensor_fusion_proxy();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_new_state_chan_29_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_sensors_output_attr_update_thread_init(&emitter_new_state_chan_29_thread_init_message_0);
    }
}

void handler_run_save_last_gyro_thread_init(const struct gyroscope_sample *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_sensor_fusion_proxy();
    /* run callbacks */
    callback_save_last_gyro_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_sensor_fusion_proxy();
    /* deliver emitters */
    ;
}

void handler_run_save_last_baro_thread_init(const struct barometer_sample *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_sensor_fusion_proxy();
    /* run callbacks */
    callback_save_last_baro_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_sensor_fusion_proxy();
    /* deliver emitters */
    ;
}

void handler_run_save_last_mag_thread_init(const struct magnetometer_sample *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_sensor_fusion_proxy();
    /* run callbacks */
    callback_save_last_mag_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_sensor_fusion_proxy();
    /* deliver emitters */
    ;
}

void handler_run_save_last_accel_thread_init(const struct accelerometer_sample *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_sensor_fusion_proxy();
    /* run callbacks */
    callback_save_last_accel_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_sensor_fusion_proxy();
    /* deliver emitters */
    ;
}

void handler_run_att_est_motion_thread_init(const bool *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_att_est_sensor_fusion();
    /* run callbacks */
    callback_att_est_motion_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_att_est_sensor_fusion();
    /* deliver emitters */
    ;
}

void handler_run_att_est_gyro_thread_init(const struct gyroscope_sample *n_var0)
{
    /* init emitters */
    emitter_att_est_gyro_chan_189_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_att_est_sensor_fusion();
    /* run callbacks */
    callback_att_est_gyro_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_att_est_sensor_fusion();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_att_est_gyro_chan_189_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_new_state_thread_init(&emitter_att_est_gyro_chan_189_thread_init_message_0);
    }
}

void handler_run_att_est_mag_thread_init(const struct magnetometer_sample *n_var0)
{
    /* init emitters */
    emitter_att_est_mag_chan_189_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_att_est_sensor_fusion();
    /* run callbacks */
    callback_att_est_mag_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_att_est_sensor_fusion();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_att_est_mag_chan_189_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_new_state_thread_init(&emitter_att_est_mag_chan_189_thread_init_message_0);
    }
}

void handler_run_att_est_accel_thread_init(const struct accelerometer_sample *n_var0)
{
    /* init emitters */
    emitter_att_est_accel_chan_189_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_att_est_sensor_fusion();
    /* run callbacks */
    callback_att_est_accel_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_att_est_sensor_fusion();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_att_est_accel_chan_189_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_new_state_thread_init(&emitter_att_est_accel_chan_189_thread_init_message_0);
    }
}

void handler_run_att_est_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_att_est_sensor_fusion();
    /* run callbacks */
    callback_att_est_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_att_est_sensor_fusion();
    /* deliver emitters */
    ;
}

void handler_run_write_mag_output_attr_thread_init(const struct magnetometer_sample *n_var0)
{
    /* init emitters */
    emitter_write_mag_output_attr_chan_34_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_mag_output_attrProxy();
    /* run callbacks */
    callback_write_mag_output_attr_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_mag_output_attrProxy();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_write_mag_output_attr_chan_34_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_mag_output_attr_update_thread_init(&emitter_write_mag_output_attr_chan_34_thread_init_message_0);
    }
}

void handler_run_write_gyro_output_attr_thread_init(const struct gyroscope_sample *n_var0)
{
    /* init emitters */
    emitter_write_gyro_output_attr_chan_30_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_gyro_output_attrProxy();
    /* run callbacks */
    callback_write_gyro_output_attr_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_gyro_output_attrProxy();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_write_gyro_output_attr_chan_30_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_gyro_output_attr_update_thread_init(&emitter_write_gyro_output_attr_chan_30_thread_init_message_0);
    }
}

void handler_run_write_baro_output_attr_thread_init(const struct barometer_sample *n_var0)
{
    /* init emitters */
    emitter_write_baro_output_attr_chan_32_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_baro_output_attrProxy();
    /* run callbacks */
    callback_write_baro_output_attr_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_baro_output_attrProxy();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_write_baro_output_attr_chan_32_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_baro_output_attr_update_thread_init(&emitter_write_baro_output_attr_chan_32_thread_init_message_0);
    }
}

void handler_run_write_accel_output_attr_thread_init(const struct accelerometer_sample *n_var0)
{
    /* init emitters */
    emitter_write_accel_output_attr_chan_31_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_accel_output_attrProxy();
    /* run callbacks */
    callback_write_accel_output_attr_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_accel_output_attrProxy();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_write_accel_output_attr_chan_31_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_accel_output_attr_update_thread_init(&emitter_write_accel_output_attr_chan_31_thread_init_message_0);
    }
}

void handler_run_motion_light_debug_2_thread_init(const bool *n_var0)
{
    /* init emitters */
    emitter_motion_light_debug_2_chan_23_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_motion_light_debug();
    /* run callbacks */
    callback_motion_light_debug_2_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_motion_light_debug();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_motion_light_debug_2_chan_23_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_rgb_led_attr_update_thread_init(&emitter_motion_light_debug_2_chan_23_thread_init_message_0);
        handler_run_set_thread_init(&emitter_motion_light_debug_2_chan_23_thread_init_message_0);
    }
}

void handler_run_detectMotion_2_accel_thread_init(const struct accelerometer_sample *n_var0)
{
    /* init emitters */
    emitter_detectMotion_2_accel_chan_188_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_detectMotion();
    /* run callbacks */
    callback_detectMotion_2_accel_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_detectMotion();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_detectMotion_2_accel_chan_188_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_motion_light_debug_2_thread_init(&emitter_detectMotion_2_accel_chan_188_thread_init_message_0);
        handler_run_att_est_motion_thread_init(&emitter_detectMotion_2_accel_chan_188_thread_init_message_0);
    }
}

void handler_run_detectMotion_2_gyro_thread_init(const struct gyroscope_sample *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_detectMotion();
    /* run callbacks */
    callback_detectMotion_2_gyro_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_detectMotion();
    /* deliver emitters */
    ;
}

void handler_run_detectMotion_2_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_detectMotion();
    /* run callbacks */
    callback_detectMotion_2_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_detectMotion();
    /* deliver emitters */
    ;
}

void handler_run_i2c1_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_i2c1PeripheralDriver();
    /* run callbacks */
    callback_i2c1_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_i2c1PeripheralDriver();
    /* deliver emitters */
    ;
}

void handler_run_spi1_scheduler_ready_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    emitter_spi1_scheduler_ready_chan_158_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_spi1_scheduler();
    /* run callbacks */
    callback_spi1_scheduler_ready_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_spi1_scheduler();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_spi1_scheduler_ready_chan_158_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_request_4_thread_init(&emitter_spi1_scheduler_ready_chan_158_thread_init_message_0);
    }
}

void handler_run_spi1_scheduler_l3gd20_thread_init(const struct spi_transaction_request *n_var0)
{
    /* init emitters */
    emitter_spi1_scheduler_l3gd20_chan_158_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_spi1_scheduler();
    /* run callbacks */
    callback_spi1_scheduler_l3gd20_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_spi1_scheduler();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_spi1_scheduler_l3gd20_chan_158_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_request_4_thread_init(&emitter_spi1_scheduler_l3gd20_chan_158_thread_init_message_0);
    }
}

void handler_run_spi1_scheduler_ms5611_thread_init(const struct spi_transaction_request *n_var0)
{
    /* init emitters */
    emitter_spi1_scheduler_ms5611_chan_158_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_spi1_scheduler();
    /* run callbacks */
    callback_spi1_scheduler_ms5611_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_spi1_scheduler();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_spi1_scheduler_ms5611_chan_158_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_request_4_thread_init(&emitter_spi1_scheduler_ms5611_chan_158_thread_init_message_0);
    }
}

void handler_run_spi1_scheduler_lsm303d_thread_init(const struct spi_transaction_request *n_var0)
{
    /* init emitters */
    emitter_spi1_scheduler_lsm303d_chan_158_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_spi1_scheduler();
    /* run callbacks */
    callback_spi1_scheduler_lsm303d_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_spi1_scheduler();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_spi1_scheduler_lsm303d_chan_158_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_request_4_thread_init(&emitter_spi1_scheduler_lsm303d_chan_158_thread_init_message_0);
    }
}

void handler_run_spi1_scheduler_mpu6000_thread_init(const struct spi_transaction_request *n_var0)
{
    /* init emitters */
    emitter_spi1_scheduler_mpu6000_chan_158_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_spi1_scheduler();
    /* run callbacks */
    callback_spi1_scheduler_mpu6000_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_spi1_scheduler();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_spi1_scheduler_mpu6000_chan_158_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_request_4_thread_init(&emitter_spi1_scheduler_mpu6000_chan_158_thread_init_message_0);
    }
}

void handler_run_ms5611_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    emitter_ms5611_init_chan_178_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_ms5611SPISensorManager();
    /* run callbacks */
    callback_ms5611_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_ms5611SPISensorManager();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_ms5611_init_chan_178_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_ms5611_thread_init(&emitter_ms5611_init_chan_178_thread_init_message_0);
    }
}

void handler_run_ms5611_thread_init(const bool *n_var0)
{
    /* init emitters */
    emitter_ms5611_chan_175_thread_init_message_count = (uint32_t) 0U;
    emitter_ms5611_chan_177_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_ms5611SPISensorManager();
    /* run callbacks */
    callback_ms5611_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_ms5611SPISensorManager();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_ms5611_chan_175_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_spi1_scheduler_ms5611_thread_init(&emitter_ms5611_chan_175_thread_init_message_0);
    }
    
    uint32_t n_deref1 = emitter_ms5611_chan_177_thread_init_message_count;
    
    if ((bool) (0 < n_deref1)) {
        handler_run_write_baro_output_attr_thread_init(&emitter_ms5611_chan_177_thread_init_message_0);
        handler_run_save_last_baro_thread_init(&emitter_ms5611_chan_177_thread_init_message_0);
    }
}

void handler_run_lsm303d_coroutine_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    emitter_lsm303d_coroutine_init_chan_174_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_lsm303dSensorManager();
    /* run callbacks */
    callback_lsm303d_coroutine_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_lsm303dSensorManager();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_lsm303d_coroutine_init_chan_174_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_lsm303d_coroutine_thread_init(&emitter_lsm303d_coroutine_init_chan_174_thread_init_message_0);
    }
}

void handler_run_lsm303d_coroutine_thread_init(const bool *n_var0)
{
    /* init emitters */
    emitter_lsm303d_coroutine_chan_170_thread_init_message_count = (uint32_t) 0U;
    emitter_lsm303d_coroutine_chan_172_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_lsm303dSensorManager();
    /* run callbacks */
    callback_lsm303d_coroutine_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_lsm303dSensorManager();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_lsm303d_coroutine_chan_170_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_spi1_scheduler_lsm303d_thread_init(&emitter_lsm303d_coroutine_chan_170_thread_init_message_0);
    }
    
    uint32_t n_deref1 = emitter_lsm303d_coroutine_chan_172_thread_init_message_count;
    
    if ((bool) (0 < n_deref1)) {
        handler_run_write_mag_output_attr_thread_init(&emitter_lsm303d_coroutine_chan_172_thread_init_message_0);
        handler_run_att_est_mag_thread_init(&emitter_lsm303d_coroutine_chan_172_thread_init_message_0);
        handler_run_save_last_mag_thread_init(&emitter_lsm303d_coroutine_chan_172_thread_init_message_0);
    }
}

void handler_run_mpu6000_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    emitter_mpu6000_init_chan_169_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_mpu6kCtl();
    /* run callbacks */
    callback_mpu6000_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_mpu6kCtl();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_mpu6000_init_chan_169_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_mpu6000_thread_init(&emitter_mpu6000_init_chan_169_thread_init_message_0);
    }
}

void handler_run_mpu6000_thread_init(const bool *n_var0)
{
    /* init emitters */
    emitter_mpu6000_chan_167_thread_init_message_count = (uint32_t) 0U;
    emitter_mpu6000_chan_157_thread_init_message_count = (uint32_t) 0U;
    emitter_mpu6000_chan_156_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_mpu6kCtl();
    /* run callbacks */
    callback_mpu6000_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_mpu6kCtl();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_mpu6000_chan_167_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_spi1_scheduler_mpu6000_thread_init(&emitter_mpu6000_chan_167_thread_init_message_0);
    }
    
    uint32_t n_deref1 = emitter_mpu6000_chan_157_thread_init_message_count;
    
    if ((bool) (0 < n_deref1)) {
        handler_run_detectMotion_2_gyro_thread_init(&emitter_mpu6000_chan_157_thread_init_message_0);
        handler_run_write_gyro_output_attr_thread_init(&emitter_mpu6000_chan_157_thread_init_message_0);
        handler_run_att_est_gyro_thread_init(&emitter_mpu6000_chan_157_thread_init_message_0);
        handler_run_save_last_gyro_thread_init(&emitter_mpu6000_chan_157_thread_init_message_0);
    }
    
    uint32_t n_deref2 = emitter_mpu6000_chan_156_thread_init_message_count;
    
    if ((bool) (0 < n_deref2)) {
        handler_run_detectMotion_2_accel_thread_init(&emitter_mpu6000_chan_156_thread_init_message_0);
        handler_run_write_accel_output_attr_thread_init(&emitter_mpu6000_chan_156_thread_init_message_0);
        handler_run_att_est_accel_thread_init(&emitter_mpu6000_chan_156_thread_init_message_0);
        handler_run_save_last_accel_thread_init(&emitter_mpu6000_chan_156_thread_init_message_0);
    }
}

void handler_run_l3gd20_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    emitter_l3gd20_init_chan_166_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_l3gd20Ctl();
    /* run callbacks */
    callback_l3gd20_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_l3gd20Ctl();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_l3gd20_init_chan_166_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_l3gd20_thread_init(&emitter_l3gd20_init_chan_166_thread_init_message_0);
    }
}

void handler_run_l3gd20_thread_init(const bool *n_var0)
{
    /* init emitters */
    emitter_l3gd20_chan_164_thread_init_message_count = (uint32_t) 0U;
    emitter_l3gd20_chan_162_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_l3gd20Ctl();
    /* run callbacks */
    callback_l3gd20_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_l3gd20Ctl();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_l3gd20_chan_164_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_spi1_scheduler_l3gd20_thread_init(&emitter_l3gd20_chan_164_thread_init_message_0);
    }
    
    uint32_t n_deref1 = emitter_l3gd20_chan_162_thread_init_message_count;
    
    if ((bool) (0 < n_deref1)) {
        handler_run_mpu6000_init_thread_init(&emitter_l3gd20_chan_162_thread_init_message_0);
        handler_run_lsm303d_coroutine_init_thread_init(&emitter_l3gd20_chan_162_thread_init_message_0);
        handler_run_ms5611_init_thread_init(&emitter_l3gd20_chan_162_thread_init_message_0);
    }
}

void handler_run_init_2_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    emitter_init_2_chan_161_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_sensor_enable();
    /* run callbacks */
    callback_init_2_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_sensor_enable();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_init_2_chan_161_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_l3gd20_init_thread_init(&emitter_init_2_chan_161_thread_init_message_0);
    }
}

void handler_run_request_4_thread_init(const struct spi_transaction_request *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_spi1PeripheralDriver();
    /* run callbacks */
    callback_request_4_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_spi1PeripheralDriver();
    /* deliver emitters */
    ;
}

void handler_run_initialize_hardware_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    emitter_initialize_hardware_chan_160_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_spi1PeripheralDriver();
    /* run callbacks */
    callback_initialize_hardware_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_spi1PeripheralDriver();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_initialize_hardware_chan_160_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_init_2_thread_init(&emitter_initialize_hardware_chan_160_thread_init_message_0);
        handler_run_spi1_scheduler_ready_thread_init(&emitter_initialize_hardware_chan_160_thread_init_message_0);
    }
}

void handler_run_write_gps_output_attr_thread_init(const struct position_sample *n_var0)
{
    /* init emitters */
    emitter_write_gps_output_attr_chan_37_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_gps_output_attrProxy();
    /* run callbacks */
    callback_write_gps_output_attr_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_gps_output_attrProxy();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_write_gps_output_attr_chan_37_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_gps_output_attr_update_thread_init(&emitter_write_gps_output_attr_chan_37_thread_init_message_0);
    }
}

void handler_run_ublox_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    emitter_ublox_init_chan_147_thread_init_message_count = (uint32_t) 0U;
    /* take monitor lock */
    monitor_lock_ubloxGPS();
    /* run callbacks */
    callback_ublox_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_ubloxGPS();
    /* deliver emitters */
    ;
    
    uint32_t n_deref0 = emitter_ublox_init_chan_147_thread_init_message_count;
    
    if ((bool) (0 < n_deref0)) {
        handler_run_write_gps_output_attr_thread_init(&emitter_ublox_init_chan_147_thread_init_message_0);
    }
}

void handler_run_gps_output_attr_update_thread_init(const struct position_sample *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_gps_output_attrServer();
    /* run callbacks */
    callback_gps_output_attr_update_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_gps_output_attrServer();
    /* deliver emitters */
    ;
}

void handler_run_mag_output_attr_update_thread_init(const struct magnetometer_sample *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_mag_output_attrServer();
    /* run callbacks */
    callback_mag_output_attr_update_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_mag_output_attrServer();
    /* deliver emitters */
    ;
}

void handler_run_baro_output_attr_update_thread_init(const struct barometer_sample *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_baro_output_attrServer();
    /* run callbacks */
    callback_baro_output_attr_update_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_baro_output_attrServer();
    /* deliver emitters */
    ;
}

void handler_run_accel_output_attr_update_thread_init(const struct accelerometer_sample *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_accel_output_attrServer();
    /* run callbacks */
    callback_accel_output_attr_update_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_accel_output_attrServer();
    /* deliver emitters */
    ;
}

void handler_run_gyro_output_attr_update_thread_init(const struct gyroscope_sample *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_gyro_output_attrServer();
    /* run callbacks */
    callback_gyro_output_attr_update_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_gyro_output_attrServer();
    /* deliver emitters */
    ;
}

void handler_run_sensors_output_attr_update_thread_init(const struct sensors_result *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_sensors_output_attrServer();
    /* run callbacks */
    callback_sensors_output_attr_update_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_sensors_output_attrServer();
    /* deliver emitters */
    ;
}

void handler_run_rgb_led_attr_update_thread_init(const struct rgb_led_setting *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_rgb_led_attrServer();
    /* run callbacks */
    callback_rgb_led_attr_update_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_rgb_led_attrServer();
    /* deliver emitters */
    ;
}

void handler_run_can_init_2_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_can_init();
    /* run callbacks */
    callback_can_init_2_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_can_init();
    /* deliver emitters */
    ;
}

void handler_run_init_thread_init(const int64_t *n_var0)
{
    /* init emitters */
    /* take monitor lock */
    monitor_lock_can1PeripheralDriver();
    /* run callbacks */
    callback_init_thread_init(n_var0);
    /* release monitor lock */
    monitor_unlock_can1PeripheralDriver();
    /* deliver emitters */
    ;
}
